# 代理服务器架构说明

> **📅 最新更新（2026-01-21）**：✅ **TCP协议支持已启用**  
> 已移除TCP限制，现在支持完整的TCP、UDP、ICMPv6转发功能

## 核心设计理念

本VPN服务器采用**应用层代理转发**方式，而不是传统的网络层转发：

### ✅ 当前实现方式（应用层代理）

```
┌─────────────────────────────────────────────────────────────┐
│                    客户端设备（PC）                          │
│                          ↓                                   │
│                   TUN虚拟网卡接口                            │
└──────────────────────┬──────────────────────────────────────┘
                       │ IP数据包
                       ↓
┌─────────────────────────────────────────────────────────────┐
│              VPN代理服务器（本项目）                         │
│                                                              │
│  1. WorkerLoop()                                            │
│     ├─ recvfrom() 读取完整IP包                             │
│     └─ 获取客户端物理地址（用于回程路由）                   │
│                                                              │
│  2. ProtocolHandler::ParseIPPacket()                        │
│     ├─ 解析IP头（源IP、目标IP）                            │
│     ├─ 解析传输层头（TCP/UDP，源端口、目标端口）           │
│     └─ 提取关键信息到PacketInfo结构                         │
│                                                              │
│  3. PacketBuilder::ExtractPayload()                         │
│     ├─ 跳过IP头（20-60字节）                                │
│     ├─ 跳过TCP/UDP头（8-60字节）                            │
│     └─ 只提取应用层数据（HTTP、DNS等）                      │
│                                                              │
│  4. PacketForwarder::ForwardPacket()                        │
│     ├─ 创建普通socket（SOCK_STREAM/SOCK_DGRAM）            │
│     ├─ sendto/send() 发送应用层payload                      │
│     └─ 不发送IP头！只发送应用数据！                        │
│                                                              │
│  5. HandleUdpResponse/HandleTcpResponse（响应线程）         │
│     ├─ recvfrom/recv() 接收应用层响应                       │
│     └─ 获取响应数据（无IP头）                               │
│                                                              │
│  6. PacketBuilder::BuildResponsePacket()                    │
│     ├─ 构建新的IP头（交换源/目标IP）                        │
│     ├─ 构建新的TCP/UDP头（交换源/目标端口）                 │
│     ├─ 计算校验和                                            │
│     └─ 封装成完整IP包                                       │
│                                                              │
│  7. sendto(g_sockFd, ipPacket, ...)                         │
│     └─ 将构建的IP包写回TUN设备                              │
└──────────────────────┬──────────────────────────────────────┘
                       │ IP数据包
                       ↓
┌─────────────────────────────────────────────────────────────┐
│                   TUN虚拟网卡接口                            │
│                          ↓                                   │
│                    客户端设备（PC）                          │
└─────────────────────────────────────────────────────────────┘
```

---

## 关键代码位置

### 1. TUN数据读取
**文件**：`entry/src/main/cpp/vpn_server.cpp`  
**函数**：`WorkerLoop()`  
**关键代码**：
```cpp
int n = recvfrom(g_sockFd, buf, sizeof(buf), 0, 
                 reinterpret_cast<sockaddr *>(&peer), &peerLen);
// buf 包含完整IP数据包
// peer 是客户端物理地址（用于NAT映射）
```

### 2. 数据包解析
**文件**：`entry/src/main/cpp/protocol_handler.cpp`  
**函数**：`ProtocolHandler::ParseIPPacket()`  
**关键代码**：
```cpp
PacketInfo packetInfo = ProtocolHandler::ParseIPPacket(buf, n);
// 解析出：
//   - packetInfo.sourceIP (VPN虚拟IP)
//   - packetInfo.targetIP (真实目标服务器IP)
//   - packetInfo.sourcePort, targetPort
//   - packetInfo.protocol (TCP/UDP)
```

### 3. Payload提取
**文件**：`entry/src/main/cpp/packet_builder.cpp`  
**函数**：`PacketBuilder::ExtractPayload()`  
**关键代码**：
```cpp
bool PacketBuilder::ExtractPayload(const uint8_t* data, int dataSize, 
                                   const PacketInfo& packetInfo,
                                   const uint8_t** outPayload, int* outSize) {
    int ipHeaderLen = (data[0] & 0x0F) * 4;
    int tcpUdpHeaderLen = (protocol == UDP) ? 8 : ((data[ipHeaderLen+12]>>4)*4);
    int payloadOffset = ipHeaderLen + tcpUdpHeaderLen;
    
    *outPayload = data + payloadOffset;  // 跳过所有头部
    *outSize = dataSize - payloadOffset;  // 只返回应用层数据
    return true;
}
```

### 4. 代理转发（核心）
**文件**：`entry/src/main/cpp/packet_forwarder.cpp`  
**函数**：`PacketForwarder::ForwardPacket()`  
**关键代码**：
```cpp
// 创建普通socket（不是raw socket！）
int sockFd = socket(AF_INET, SOCK_DGRAM, 0);  // UDP
// 或
int sockFd = socket(AF_INET, SOCK_STREAM, 0);  // TCP

// 只发送payload，不发送IP头！
sendto(sockFd, payload, payloadSize, 0, 
       (struct sockaddr*)&targetAddr, sizeof(targetAddr));
// payload: 应用层数据（HTTP请求、DNS查询等）
// 不包含：IP头、TCP/UDP头
```

### 5. 响应处理
**文件**：`entry/src/main/cpp/packet_forwarder.cpp`  
**函数**：`HandleUdpResponseSimple()` / `HandleTcpResponseSimple()`  
**关键代码**：
```cpp
// 接收响应（只有应用层数据）
ssize_t received = recvfrom(sockFd, responsePayload, sizeof(responsePayload), 0, ...);
// responsePayload: HTTP响应、DNS应答等（无IP头）

// 构建完整IP包
uint8_t ipPacket[4096 + 60];
int packetLen = PacketBuilder::BuildResponsePacket(
    ipPacket, sizeof(ipPacket),
    responsePayload, received,  // 应用层数据
    conn.originalRequest        // 原始请求信息
);

// 写回TUN设备
sendto(g_sockFd, ipPacket, packetLen, 0, 
       (struct sockaddr*)&conn.clientPhysicalAddr, ...);
```

---

## 与Raw Socket方式的对比

### ❌ Raw Socket方式（未使用）
```cpp
// 错误示例（本项目不使用）
int rawSock = socket(AF_INET, SOCK_RAW, IPPROTO_RAW);
sendto(rawSock, entireIPPacket, packetSize, 0, ...);
// 直接发送整个IP包，包括IP头
```

**缺点**：
- 需要root权限
- 需要手动处理IP路由
- 容易造成路由循环
- 不能穿透NAT

### ✅ 应用层代理方式（本项目使用）
```cpp
// 正确方式（本项目采用）
int sock = socket(AF_INET, SOCK_DGRAM, 0);  // 普通socket
sendto(sock, payload, payloadSize, 0, ...);  // 只发送数据
// 系统自动处理IP头、路由、NAT穿透
```

**优点**：
- 不需要root权限
- 系统自动处理路由
- 不会造成路由循环
- 可以穿透NAT
- 性能更好

---

## NAT映射表

为了将响应正确路由回客户端，服务器维护一个NAT映射表：

```cpp
struct NATConnection {
    sockaddr_in clientPhysicalAddr;  // 客户端物理地址（recvfrom获取）
    int forwardSocket;                // 转发socket
    PacketInfo originalRequest;       // 原始请求信息
};

// 转发时创建映射
std::string natKey = GenerateKey(packetInfo);
NATTable::CreateMapping(natKey, originalPeer, packetInfo, sockFd);

// 响应时查找映射
NATConnection conn;
if (NATTable::FindMappingBySocket(sockFd, conn)) {
    // 将响应发送回正确的客户端
    sendto(g_sockFd, ipPacket, packetLen, 0,
           (struct sockaddr*)&conn.clientPhysicalAddr, ...);
}
```

---

## 数据包示例

### UDP DNS查询示例

#### 1. 客户端发送（TUN → 服务器）
```
[IP头: 20字节]
  源IP: 10.20.1.2 (VPN虚拟IP)
  目标IP: 8.8.8.8 (Google DNS)
[UDP头: 8字节]
  源端口: 54321
  目标端口: 53
[DNS查询: 32字节]
  查询: www.baidu.com A记录
```

#### 2. 服务器转发（服务器 → Google DNS）
```
[只发送DNS查询数据]
  查询: www.baidu.com A记录 (32字节)
[IP头由操作系统自动添加]
  源IP: 服务器真实IP (自动)
  目标IP: 8.8.8.8 (我们指定)
[UDP头由操作系统自动添加]
  源端口: 随机端口 (自动)
  目标端口: 53 (我们指定)
```

#### 3. 服务器接收响应（Google DNS → 服务器）
```
[只收到DNS响应数据]
  应答: 110.242.68.66 (48字节)
[IP头和UDP头由操作系统自动处理]
```

#### 4. 服务器构建并发送（服务器 → TUN → 客户端）
```
[IP头: 20字节] (我们构建)
  源IP: 8.8.8.8 (交换)
  目标IP: 10.20.1.2 (交换)
[UDP头: 8字节] (我们构建)
  源端口: 53 (交换)
  目标端口: 54321 (交换)
[DNS响应: 48字节] (原样)
  应答: 110.242.68.66
```

---

## 总结

### 本项目实现方式

✅ **应用层代理转发**
- 从TUN读取完整IP包
- 解析并提取payload
- 使用普通socket转发payload
- 构建响应IP包写回TUN

❌ **不是网络层转发**
- 不使用raw socket
- 不直接转发IP包
- 不依赖内核路由表

### 为什么需要TUN设备？

TUN设备是客户端和服务器之间的**数据通道**：
- 客户端通过TUN发送IP包（操作系统认为TUN是真实网卡）
- 服务器从TUN读取IP包（应用层读取）
- 服务器处理后写回TUN（应用层写入）
- 客户端从TUN接收IP包（操作系统自动处理）

**TUN设备本身是虚拟网卡，但服务器使用的是应用层代理方式处理数据！**

---

## 代码调用链

```
主线程：
  StartServer()
    └─> WorkerLoop() [vpn_server.cpp:1029]

每次收到数据包：
  WorkerLoop()
    └─> ProtocolHandler::ParseIPPacket() [protocol_handler.cpp:11]
         └─> PacketForwarder::ForwardPacket() [packet_forwarder.cpp:39]
              ├─> PacketBuilder::ExtractPayload() [packet_builder.cpp]
              ├─> socket() + sendto()  [packet_forwarder.cpp:223]
              └─> std::thread(HandleUdpResponse) [packet_forwarder.cpp:266]

响应线程：
  HandleUdpResponseSimple() [packet_forwarder.cpp:356]
    ├─> recvfrom() 接收响应
    ├─> PacketBuilder::BuildResponsePacket() [packet_builder.cpp]
    └─> sendto(g_sockFd, ...) 写回TUN
```

---

## 如何验证是代理方式？

### 1. 检查socket类型
```cpp
// 代理方式：普通socket
int sock = socket(AF_INET, SOCK_DGRAM, 0);  ✅

// 非代理方式：raw socket
int sock = socket(AF_INET, SOCK_RAW, IPPROTO_RAW);  ❌
```

### 2. 检查发送内容
```cpp
// 代理方式：只发送payload
sendto(sock, payload, payloadSize, ...);  ✅
// payload指向应用层数据，不包含IP头

// 非代理方式：发送整个IP包
sendto(sock, ipPacket, totalPacketSize, ...);  ❌
// ipPacket包含IP头
```

### 3. 查看代码实现
```cpp
// packet_forwarder.cpp:52-63
if (!PacketBuilder::ExtractPayload(data, dataSize, packetInfo, 
                                   &payload, &payloadSize)) {
    return -1;
}
// ✅ 提取payload，说明是代理方式
```

---

**结论**：当前代码已经实现了完整的应用层代理转发架构，无需修改！
