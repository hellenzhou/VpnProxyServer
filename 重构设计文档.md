# VPN Proxy Server - å®Œå…¨é‡æ„è®¾è®¡æ–‡æ¡£

## ğŸ“‹ ç›®å½•
1. [æ¶æ„æ¦‚è§ˆ](#æ¶æ„æ¦‚è§ˆ)
2. [æ ¸å¿ƒè®¾è®¡](#æ ¸å¿ƒè®¾è®¡)
3. [æ¨¡å—è¯¦è§£](#æ¨¡å—è¯¦è§£)
4. [å®ç°è®¡åˆ’](#å®ç°è®¡åˆ’)
5. [è¿ç§»ç­–ç•¥](#è¿ç§»ç­–ç•¥)

---

## ğŸ—ï¸ æ¶æ„æ¦‚è§ˆ

### æ–°æ¶æ„å›¾

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                        Application                          â”‚
â”‚                     (VpnServerApp)                          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                         â”‚
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚                â”‚                â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Network     â”‚ â”‚   Packet   â”‚ â”‚   Resource    â”‚
â”‚   Layer       â”‚ â”‚  Processing â”‚ â”‚   Manager     â”‚
â”‚               â”‚ â”‚    Layer    â”‚ â”‚               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜
        â”‚               â”‚               â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚           Async I/O Framework                  â”‚
â”‚           (Boost.Asio / libuv)                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### è®¾è®¡åŸåˆ™

1. **å•ä¸€èŒè´£**ï¼šæ¯ä¸ªç±»åªåšä¸€ä»¶äº‹
2. **ä¾èµ–æ³¨å…¥**ï¼šæ–¹ä¾¿æµ‹è¯•å’Œæ›¿æ¢
3. **æ¥å£éš”ç¦»**ï¼šä¾èµ–æŠ½è±¡ï¼Œä¸ä¾èµ–å…·ä½“å®ç°
4. **å¼€é—­åŸåˆ™**ï¼šå¯¹æ‰©å±•å¼€æ”¾ï¼Œå¯¹ä¿®æ”¹å…³é—­
5. **RAII**ï¼šèµ„æºè‡ªåŠ¨ç®¡ç†

---

## ğŸ¨ æ ¸å¿ƒè®¾è®¡

### 1. äº‹ä»¶é©±åŠ¨æ¨¡å‹

```
ä¸»äº‹ä»¶å¾ªç¯ï¼ˆå•çº¿ç¨‹ï¼‰
    â†“
æ¥æ”¶ç½‘ç»œäº‹ä»¶
    â†“
è§£ææ•°æ®åŒ…ï¼ˆè½»é‡çº§ï¼‰
    â†“
æäº¤åˆ°çº¿ç¨‹æ± ï¼ˆé‡é‡çº§ä»»åŠ¡ï¼‰
    â†“
å¤„ç†å®Œæˆåé€šè¿‡äº‹ä»¶é€šçŸ¥ä¸»å¾ªç¯
    â†“
å‘é€å“åº”
```

**ä¼˜åŠ¿ï¼š**
- ä¸»å¾ªç¯æ°¸ä¸é˜»å¡
- å……åˆ†åˆ©ç”¨å¤šæ ¸
- èµ„æºå¯æ§

### 2. æ¨¡å—åˆ’åˆ†

```cpp
// æ ¸å¿ƒæ¨¡å—
â”œâ”€â”€ core/
â”‚   â”œâ”€â”€ VpnServer.h/cpp          // æœåŠ¡å™¨ä¸»ç±»
â”‚   â”œâ”€â”€ Config.h/cpp             // é…ç½®ç®¡ç†
â”‚   â””â”€â”€ EventLoop.h/cpp          // äº‹ä»¶å¾ªç¯
â”‚
// ç½‘ç»œå±‚
â”œâ”€â”€ network/
â”‚   â”œâ”€â”€ SocketManager.h/cpp      // Socket ç®¡ç†
â”‚   â”œâ”€â”€ UdpSocket.h/cpp          // UDP Socket å°è£…
â”‚   â”œâ”€â”€ AsyncReceiver.h/cpp      // å¼‚æ­¥æ¥æ”¶
â”‚   â””â”€â”€ AsyncSender.h/cpp        // å¼‚æ­¥å‘é€
â”‚
// æ•°æ®åŒ…å¤„ç†å±‚
â”œâ”€â”€ packet/
â”‚   â”œâ”€â”€ PacketParser.h/cpp       // æ•°æ®åŒ…è§£æ
â”‚   â”œâ”€â”€ PacketBuilder.h/cpp      // æ•°æ®åŒ…æ„å»º
â”‚   â”œâ”€â”€ PacketValidator.h/cpp    // æ•°æ®åŒ…éªŒè¯
â”‚   â””â”€â”€ ProtocolHandler.h/cpp    // åè®®å¤„ç†
â”‚
// è½¬å‘å±‚
â”œâ”€â”€ forwarding/
â”‚   â”œâ”€â”€ Forwarder.h/cpp          // è½¬å‘å™¨
â”‚   â”œâ”€â”€ NATTable.h/cpp           // NAT è¡¨ï¼ˆé‡æ–°è®¾è®¡ï¼‰
â”‚   â”œâ”€â”€ SessionManager.h/cpp     // ä¼šè¯ç®¡ç†
â”‚   â””â”€â”€ DNSCache.h/cpp           // DNS ç¼“å­˜
â”‚
// èµ„æºç®¡ç†
â”œâ”€â”€ resource/
â”‚   â”œâ”€â”€ ThreadPool.h/cpp         // çº¿ç¨‹æ± 
â”‚   â”œâ”€â”€ ObjectPool.h/cpp         // å¯¹è±¡æ± 
â”‚   â”œâ”€â”€ MemoryPool.h/cpp         // å†…å­˜æ± 
â”‚   â””â”€â”€ ResourceGuard.h          // RAII å·¥å…·
â”‚
// å·¥å…·ç±»
â””â”€â”€ util/
    â”œâ”€â”€ Logger.h/cpp             // æ—¥å¿—ç³»ç»Ÿ
    â”œâ”€â”€ Error.h/cpp              // é”™è¯¯å¤„ç†
    â”œâ”€â”€ Metrics.h/cpp            // æ€§èƒ½æŒ‡æ ‡
    â””â”€â”€ CircularBuffer.h/cpp     // ç¯å½¢ç¼“å†²åŒº
```

### 3. ç±»å±‚æ¬¡ç»“æ„

```cpp
// 1. æœåŠ¡å™¨ä¸»ç±»
class VpnServer {
public:
    VpnServer(Config config);
    ~VpnServer();
    
    bool Start();
    void Stop();
    void WaitForShutdown();
    
    // ç»Ÿè®¡ä¿¡æ¯
    ServerStats GetStats() const;
    
private:
    class Impl;  // PIMPL æ¨¡å¼
    std::unique_ptr<Impl> impl_;
};

// 2. äº‹ä»¶å¾ªç¯
class EventLoop {
public:
    void Run();
    void Stop();
    
    // æ³¨å†Œäº‹ä»¶å¤„ç†å™¨
    void AddSocket(Socket& socket, EventType events);
    void RemoveSocket(Socket& socket);
    
private:
    int epollFd_;  // Linux epoll
    bool running_;
};

// 3. Socket ç®¡ç†å™¨
class SocketManager {
public:
    // åˆ›å»º socket
    std::shared_ptr<Socket> CreateSocket(SocketType type);
    
    // å¼‚æ­¥æ“ä½œ
    void AsyncReceive(Socket& socket, ReceiveCallback callback);
    void AsyncSend(Socket& socket, Buffer data, SendCallback callback);
    
private:
    EventLoop& eventLoop_;
    std::map<int, std::shared_ptr<Socket>> sockets_;
};

// 4. æ•°æ®åŒ…å¤„ç†å™¨
class PacketProcessor {
public:
    void ProcessPacket(Buffer packet, SocketAddress from);
    
private:
    PacketParser parser_;
    PacketValidator validator_;
    Forwarder forwarder_;
};

// 5. è½¬å‘å™¨
class Forwarder {
public:
    void Forward(Packet packet, SocketAddress originalClient);
    
private:
    NATTable natTable_;
    SessionManager sessionManager_;
    SocketManager& socketManager_;
    ThreadPool& threadPool_;
};

// 6. NAT è¡¨ï¼ˆåˆ†æ®µé”è®¾è®¡ï¼‰
class NATTable {
public:
    void CreateMapping(SessionKey key, NATEntry entry);
    std::optional<NATEntry> FindMapping(SessionKey key);
    void RemoveMapping(SessionKey key);
    void CleanupExpired();
    
private:
    static constexpr size_t NUM_SHARDS = 16;
    
    struct Shard {
        std::unordered_map<SessionKey, NATEntry> entries;
        mutable std::shared_mutex mutex;  // è¯»å†™é”
    };
    
    std::array<Shard, NUM_SHARDS> shards_;
    
    Shard& GetShard(const SessionKey& key);
};

// 7. çº¿ç¨‹æ± 
class ThreadPool {
public:
    ThreadPool(size_t numThreads);
    ~ThreadPool();
    
    template<typename Func>
    auto Submit(Func&& func) -> std::future<decltype(func())>;
    
private:
    std::vector<std::thread> workers_;
    std::queue<std::function<void()>> tasks_;
    std::mutex mutex_;
    std::condition_variable condition_;
    bool stop_;
};

// 8. é…ç½®ç®¡ç†
struct Config {
    std::string listenAddress = "127.0.0.1";
    uint16_t listenPort = 8888;
    
    size_t numThreads = std::thread::hardware_concurrency();
    size_t maxConnections = 10000;
    
    std::chrono::seconds sessionTimeout{300};
    std::chrono::seconds dnsTimeout{5};
    
    bool enableDNSCache = true;
    bool enableMetrics = true;
    
    LogLevel logLevel = LogLevel::INFO;
    
    static Config LoadFromFile(const std::string& path);
};
```

---

## ğŸ“¦ å…³é”®æ•°æ®ç»“æ„

### 1. æ•°æ®åŒ…è¡¨ç¤º

```cpp
// è½»é‡çº§æ•°æ®åŒ…å¼•ç”¨ï¼ˆé›¶æ‹·è´ï¼‰
class PacketView {
public:
    PacketView(const uint8_t* data, size_t size);
    
    uint8_t GetIPVersion() const;
    uint8_t GetProtocol() const;
    std::string_view GetSourceIP() const;
    std::string_view GetDestIP() const;
    uint16_t GetSourcePort() const;
    uint16_t GetDestPort() const;
    
    std::span<const uint8_t> GetPayload() const;
    
private:
    const uint8_t* data_;
    size_t size_;
    
    // ç¼“å­˜è§£æç»“æœ
    mutable std::optional<ParsedInfo> cached_;
};

// å¯ä¿®æ”¹çš„æ•°æ®åŒ…
class Packet {
public:
    Packet(size_t capacity = 2048);
    
    void SetIPHeader(const IPHeader& header);
    void SetTransportHeader(const TransportHeader& header);
    void SetPayload(std::span<const uint8_t> payload);
    
    std::vector<uint8_t> Build() const;
    
private:
    std::vector<uint8_t> buffer_;
};
```

### 2. ä¼šè¯è¡¨ç¤º

```cpp
// ä¼šè¯ Keyï¼ˆç”¨äº NAT è¡¨ï¼‰
struct SessionKey {
    std::string clientVirtualIP;
    uint16_t clientVirtualPort;
    std::string serverIP;
    uint16_t serverPort;
    Protocol protocol;
    
    // ç”¨äº hash
    size_t Hash() const;
    bool operator==(const SessionKey& other) const;
};

// NAT æ˜ å°„æ¡ç›®
struct NATEntry {
    SocketAddress clientPhysicalAddr;  // å®¢æˆ·ç«¯çœŸå®åœ°å€
    std::shared_ptr<Socket> forwardSocket;  // è½¬å‘ socket
    std::chrono::steady_clock::time_point lastActivity;
    PacketView originalRequest;  // åŸå§‹è¯·æ±‚ï¼ˆç”¨äºæ„å»ºå“åº”ï¼‰
    
    bool IsExpired(std::chrono::seconds timeout) const;
};

// ä¼šè¯ç»Ÿè®¡
struct SessionStats {
    uint64_t packetsForwarded = 0;
    uint64_t bytesForwarded = 0;
    uint64_t packetsReceived = 0;
    uint64_t bytesReceived = 0;
    std::chrono::steady_clock::time_point createdAt;
};
```

### 3. é”™è¯¯å¤„ç†

```cpp
enum class ErrorCode {
    SUCCESS = 0,
    
    // ç½‘ç»œé”™è¯¯
    SOCKET_ERROR = 1000,
    BIND_FAILED,
    SEND_FAILED,
    RECEIVE_FAILED,
    
    // æ•°æ®åŒ…é”™è¯¯
    INVALID_PACKET = 2000,
    PACKET_TOO_SMALL,
    UNSUPPORTED_PROTOCOL,
    CHECKSUM_ERROR,
    
    // NAT é”™è¯¯
    NAT_TABLE_FULL = 3000,
    SESSION_NOT_FOUND,
    SESSION_EXPIRED,
    
    // ç³»ç»Ÿé”™è¯¯
    OUT_OF_MEMORY = 4000,
    THREAD_POOL_FULL,
    INTERNAL_ERROR
};

class Error {
public:
    Error(ErrorCode code, std::string message);
    
    ErrorCode Code() const { return code_; }
    const std::string& Message() const { return message_; }
    
    // ä¾¿æ·å‡½æ•°
    static Error Success() { return Error(ErrorCode::SUCCESS, ""); }
    static Error SocketError(const std::string& detail);
    static Error InvalidPacket(const std::string& detail);
    
private:
    ErrorCode code_;
    std::string message_;
};

// Result æ¨¡å¼
template<typename T>
class Result {
public:
    static Result Success(T value);
    static Result Failure(Error error);
    
    bool IsSuccess() const;
    const T& Value() const;
    const Error& GetError() const;
    
private:
    std::variant<T, Error> data_;
};
```

---

## ğŸ”§ å®ç°ç»†èŠ‚

### 1. äº‹ä»¶å¾ªç¯ï¼ˆLinux epollï¼‰

```cpp
class EventLoop {
public:
    EventLoop() {
        epollFd_ = epoll_create1(0);
        if (epollFd_ < 0) {
            throw std::runtime_error("Failed to create epoll");
        }
    }
    
    ~EventLoop() {
        if (epollFd_ >= 0) {
            close(epollFd_);
        }
    }
    
    void AddSocket(int fd, uint32_t events, EventHandler* handler) {
        epoll_event ev{};
        ev.events = events;
        ev.data.ptr = handler;
        
        if (epoll_ctl(epollFd_, EPOLL_CTL_ADD, fd, &ev) < 0) {
            throw std::runtime_error("Failed to add socket to epoll");
        }
    }
    
    void Run() {
        running_ = true;
        const int MAX_EVENTS = 128;
        epoll_event events[MAX_EVENTS];
        
        while (running_) {
            int nfds = epoll_wait(epollFd_, events, MAX_EVENTS, 100);
            
            if (nfds < 0) {
                if (errno == EINTR) continue;
                throw std::runtime_error("epoll_wait failed");
            }
            
            for (int i = 0; i < nfds; i++) {
                auto* handler = static_cast<EventHandler*>(events[i].data.ptr);
                handler->OnEvent(events[i].events);
            }
            
            // å®šæœŸæ¸…ç†
            PerformMaintenance();
        }
    }
    
    void Stop() {
        running_ = false;
    }
    
private:
    int epollFd_;
    std::atomic<bool> running_;
    
    void PerformMaintenance() {
        // å®šæœŸæ¸…ç†è¿‡æœŸä¼šè¯ç­‰
    }
};
```

### 2. å¼‚æ­¥æ¥æ”¶

```cpp
class AsyncReceiver {
public:
    using ReceiveCallback = std::function<void(Result<Buffer>, SocketAddress)>;
    
    AsyncReceiver(Socket& socket, EventLoop& eventLoop)
        : socket_(socket), eventLoop_(eventLoop) {
        
        eventLoop_.AddSocket(socket.GetFd(), EPOLLIN, this);
    }
    
    void AsyncReceive(ReceiveCallback callback) {
        std::lock_guard<std::mutex> lock(mutex_);
        callbacks_.push(std::move(callback));
    }
    
    void OnEvent(uint32_t events) override {
        if (events & EPOLLIN) {
            HandleReadable();
        }
    }
    
private:
    Socket& socket_;
    EventLoop& eventLoop_;
    std::queue<ReceiveCallback> callbacks_;
    std::mutex mutex_;
    
    void HandleReadable() {
        ReceiveCallback callback;
        {
            std::lock_guard<std::mutex> lock(mutex_);
            if (callbacks_.empty()) return;
            callback = std::move(callbacks_.front());
            callbacks_.pop();
        }
        
        Buffer buffer(2048);
        sockaddr_in addr{};
        socklen_t addrLen = sizeof(addr);
        
        ssize_t n = recvfrom(socket_.GetFd(), buffer.data(), buffer.size(), 0,
                            (sockaddr*)&addr, &addrLen);
        
        if (n > 0) {
            buffer.resize(n);
            callback(Result<Buffer>::Success(std::move(buffer)), 
                    SocketAddress(addr));
        } else {
            callback(Result<Buffer>::Failure(Error::SocketError("recvfrom failed")),
                    SocketAddress());
        }
    }
};
```

### 3. åˆ†æ®µé” NAT è¡¨

```cpp
class NATTable {
public:
    void CreateMapping(const SessionKey& key, NATEntry entry) {
        auto& shard = GetShard(key);
        std::unique_lock lock(shard.mutex);  // å†™é”
        
        shard.entries[key] = std::move(entry);
    }
    
    std::optional<NATEntry> FindMapping(const SessionKey& key) {
        auto& shard = GetShard(key);
        std::shared_lock lock(shard.mutex);  // è¯»é”
        
        auto it = shard.entries.find(key);
        if (it != shard.entries.end()) {
            return it->second;
        }
        return std::nullopt;
    }
    
    void CleanupExpired(std::chrono::seconds timeout) {
        auto now = std::chrono::steady_clock::now();
        
        // å¹¶è¡Œæ¸…ç†æ‰€æœ‰åˆ†ç‰‡
        std::vector<std::future<size_t>> futures;
        
        for (auto& shard : shards_) {
            futures.push_back(std::async(std::launch::async, [&shard, now, timeout]() {
                std::unique_lock lock(shard.mutex);
                size_t removed = 0;
                
                for (auto it = shard.entries.begin(); it != shard.entries.end();) {
                    if (now - it->second.lastActivity > timeout) {
                        it = shard.entries.erase(it);
                        removed++;
                    } else {
                        ++it;
                    }
                }
                
                return removed;
            }));
        }
        
        // ç­‰å¾…æ‰€æœ‰æ¸…ç†å®Œæˆ
        size_t totalRemoved = 0;
        for (auto& future : futures) {
            totalRemoved += future.get();
        }
        
        LOG_INFO("Cleaned up {} expired sessions", totalRemoved);
    }
    
private:
    static constexpr size_t NUM_SHARDS = 16;
    
    struct Shard {
        std::unordered_map<SessionKey, NATEntry> entries;
        mutable std::shared_mutex mutex;
    };
    
    std::array<Shard, NUM_SHARDS> shards_;
    
    Shard& GetShard(const SessionKey& key) {
        return shards_[key.Hash() % NUM_SHARDS];
    }
};
```

---

## ğŸ“ˆ æ€§èƒ½ä¼˜åŒ–

### 1. é›¶æ‹·è´è®¾è®¡

```cpp
// ä½¿ç”¨ std::span å’Œ std::string_view é¿å…æ‹·è´
class PacketView {
    std::span<const uint8_t> data_;
    
public:
    std::span<const uint8_t> GetPayload() const {
        // è¿”å›å¼•ç”¨ï¼Œä¸æ‹·è´
        return data_.subspan(headerLength_);
    }
};
```

### 2. å¯¹è±¡æ± 

```cpp
template<typename T>
class ObjectPool {
public:
    ObjectPool(size_t capacity) {
        for (size_t i = 0; i < capacity; i++) {
            pool_.push(std::make_unique<T>());
        }
    }
    
    std::unique_ptr<T> Acquire() {
        std::lock_guard lock(mutex_);
        if (pool_.empty()) {
            return std::make_unique<T>();  // åŠ¨æ€åˆ›å»º
        }
        auto obj = std::move(pool_.top());
        pool_.pop();
        return obj;
    }
    
    void Release(std::unique_ptr<T> obj) {
        std::lock_guard lock(mutex_);
        pool_.push(std::move(obj));
    }
    
private:
    std::stack<std::unique_ptr<T>> pool_;
    std::mutex mutex_;
};

// ä½¿ç”¨
ObjectPool<Packet> packetPool{1000};
auto packet = packetPool.Acquire();
// ... ä½¿ç”¨ packet ...
packetPool.Release(std::move(packet));
```

### 3. å†…å­˜æ± 

```cpp
class MemoryPool {
public:
    void* Allocate(size_t size) {
        // ä½¿ç”¨å›ºå®šå¤§å°å—åˆ†é…
        // é¿å…é¢‘ç¹ malloc/free
    }
    
    void Deallocate(void* ptr) {
        // å›æ”¶åˆ°æ± ä¸­
    }
};
```

---

## ğŸ“Š ç›‘æ§å’ŒæŒ‡æ ‡

```cpp
class Metrics {
public:
    // è®¡æ•°å™¨
    void IncrementPacketsReceived() { packetsReceived_++; }
    void IncrementPacketsSent() { packetsSent_++; }
    void IncrementErrors() { errors_++; }
    
    // ç›´æ–¹å›¾
    void RecordLatency(std::chrono::microseconds latency) {
        latencyHistogram_.Record(latency.count());
    }
    
    // å¯¼å‡ºæŒ‡æ ‡ï¼ˆPrometheus æ ¼å¼ï¼‰
    std::string ExportMetrics() const;
    
private:
    std::atomic<uint64_t> packetsReceived_{0};
    std::atomic<uint64_t> packetsSent_{0};
    std::atomic<uint64_t> errors_{0};
    
    Histogram latencyHistogram_;
};
```

---

## ğŸ§ª æµ‹è¯•ç­–ç•¥

### 1. å•å…ƒæµ‹è¯•

```cpp
TEST(NATTable, CreateAndFindMapping) {
    NATTable table;
    SessionKey key{"10.0.0.1", 12345, "8.8.8.8", 53, Protocol::UDP};
    NATEntry entry{...};
    
    table.CreateMapping(key, entry);
    
    auto found = table.FindMapping(key);
    ASSERT_TRUE(found.has_value());
    EXPECT_EQ(found->clientPhysicalAddr, entry.clientPhysicalAddr);
}

TEST(PacketParser, ParseUDPPacket) {
    uint8_t data[] = {/* ... UDP packet ... */};
    PacketView packet(data, sizeof(data));
    
    EXPECT_EQ(packet.GetProtocol(), Protocol::UDP);
    EXPECT_EQ(packet.GetDestPort(), 53);
}
```

### 2. é›†æˆæµ‹è¯•

```cpp
TEST(VpnServer, StartAndStop) {
    Config config;
    config.listenPort = 0;  // éšæœºç«¯å£
    
    VpnServer server(config);
    ASSERT_TRUE(server.Start());
    
    // å‘é€æµ‹è¯•æ•°æ®åŒ…
    // ...
    
    server.Stop();
}
```

### 3. æ€§èƒ½æµ‹è¯•

```cpp
BENCHMARK(NATTableLookup) {
    NATTable table;
    // é¢„å¡«å…… 1000 ä¸ªæ¡ç›®
    // ...
    
    for (auto _ : state) {
        auto result = table.FindMapping(randomKey());
    }
}
```

---

## ğŸš€ å®Œæ•´ç¤ºä¾‹

### main.cpp

```cpp
#include "core/VpnServer.h"
#include "core/Config.h"
#include "util/Logger.h"

int main(int argc, char** argv) {
    try {
        // åˆå§‹åŒ–æ—¥å¿—
        Logger::Initialize(LogLevel::INFO);
        
        // åŠ è½½é…ç½®
        Config config = Config::LoadFromFile("config.json");
        
        // åˆ›å»ºæœåŠ¡å™¨
        VpnServer server(config);
        
        // å¯åŠ¨æœåŠ¡å™¨
        if (!server.Start()) {
            LOG_ERROR("Failed to start server");
            return 1;
        }
        
        LOG_INFO("VPN Server started on {}:{}", 
                 config.listenAddress, config.listenPort);
        
        // ç­‰å¾…åœæ­¢ä¿¡å·
        server.WaitForShutdown();
        
        LOG_INFO("Server stopped gracefully");
        return 0;
        
    } catch (const std::exception& e) {
        LOG_ERROR("Fatal error: {}", e.what());
        return 1;
    }
}
```

---

ç»§ç»­ä¸‹ä¸€éƒ¨åˆ†ï¼Ÿæˆ‘å¯ä»¥æä¾›ï¼š
1. å®Œæ•´çš„å®ç°ä»£ç æ–‡ä»¶
2. è¿ç§»è®¡åˆ’å’Œæ­¥éª¤
3. æ€§èƒ½å¯¹æ¯”æµ‹è¯•
4. éƒ¨ç½²æŒ‡å—
