/*
 * VPNæœåŠ¡å™¨æ•°æ®åŒ…è½¬å‘å™¨å®ç° - é‡æ„ç‰ˆ
 * æ ¸å¿ƒæ”¹è¿›ï¼š
 * 1. åªè½¬å‘payloadï¼ˆåº”ç”¨å±‚æ•°æ®ï¼‰ï¼Œä¸è½¬å‘å®Œæ•´IPåŒ…
 * 2. ä½¿ç”¨NATè¡¨ç®¡ç†è¿æ¥çŠ¶æ€
 * 3. æ­£ç¡®å°è£…å“åº”åŒ…
 */

#include "packet_forwarder.h"
#include "vpn_server_globals.h"
#include "simple_dns_cache.h"
#include "packet_builder.h"
#include "nat_table.h"
#include <hilog/log.h>
#include <thread>
#include <unistd.h>
#include <fcntl.h>
#include <errno.h>
#include <cstring>
#include <arpa/inet.h>
#include <sys/select.h>
#include <sys/time.h>
#include <sys/socket.h>

// æ—¥å¿—å®å®šä¹‰
#define MAKE_FILE_NAME (strrchr(__FILE__, '/') ? (strrchr(__FILE__, '/') + 1) : __FILE__)
#define VPN_SERVER_LOGE(fmt, ...) \
  OH_LOG_Print(LOG_APP, LOG_INFO, 0x15b1, "VpnServer", "[%{public}s:%{public}d] " fmt, MAKE_FILE_NAME, __LINE__, ##__VA_ARGS__)
#define VPN_SERVER_LOGI(fmt, ...) \
  OH_LOG_Print(LOG_APP, LOG_INFO, 0x15b1, "VpnServer", "[%{public}s:%{public}d] " fmt, MAKE_FILE_NAME, __LINE__, ##__VA_ARGS__)

// è½¬å‘æ•°æ®åŒ…åˆ°çœŸå®æœåŠ¡å™¨ - é‡æ„ç‰ˆ
int PacketForwarder::ForwardPacket(const uint8_t* data, int dataSize, 
                                  const PacketInfo& packetInfo, 
                                  const sockaddr_in& originalPeer) {
    VPN_SERVER_LOGI("ğŸ“¦ [è½¬å‘-æ–°] å¼€å§‹: %{public}s:%{public}d -> %{public}s:%{public}d (%{public}s)",
                    packetInfo.sourceIP.c_str(), packetInfo.sourcePort,
                    packetInfo.targetIP.c_str(), packetInfo.targetPort,
                    ProtocolHandler::GetProtocolName(packetInfo.protocol).c_str());
    
    // 1. ä»å®Œæ•´IPåŒ…ä¸­æå–payloadï¼ˆåº”ç”¨å±‚æ•°æ®ï¼‰
    const uint8_t* payload = nullptr;
    int payloadSize = 0;
    
    if (!PacketBuilder::ExtractPayload(data, dataSize, packetInfo, &payload, &payloadSize)) {
        VPN_SERVER_LOGE("âŒ [è½¬å‘-æ–°] æ— æ³•æå–payload");
        return -1;
    }
    
    if (payloadSize <= 0) {
        VPN_SERVER_LOGI("â„¹ï¸ [è½¬å‘-æ–°] payloadä¸ºç©ºï¼ˆå¯èƒ½æ˜¯TCPæ§åˆ¶åŒ…ï¼‰ï¼Œè·³è¿‡");
        return 0;  // TCP SYN/ACKç­‰æ§åˆ¶åŒ…æ²¡æœ‰payloadï¼Œè¿™æ˜¯æ­£å¸¸çš„
    }
    
    VPN_SERVER_LOGI("âœ… [è½¬å‘-æ–°] æå–payload: %{public}då­—èŠ‚", payloadSize);
    
    // 2. æ£€æŸ¥æ˜¯å¦å·²æœ‰NATæ˜ å°„ï¼ˆç”¨äºè¿æ¥å¤ç”¨ï¼‰
    std::string natKey = NATTable::GenerateKey(packetInfo);
    NATConnection existingConn;
    
    if (NATTable::FindMapping(natKey, existingConn)) {
        // è¿æ¥å·²å­˜åœ¨ï¼Œå¤ç”¨socket
        VPN_SERVER_LOGI("â™»ï¸ [è½¬å‘-æ–°] å¤ç”¨ç°æœ‰è¿æ¥: socket=%{public}d", existingConn.forwardSocket);
        
        // æ›´æ–°æ´»åŠ¨æ—¶é—´
        NATTable::UpdateActivity(natKey);
        
        // ç›´æ¥å‘é€payload
        ssize_t sent = send(existingConn.forwardSocket, payload, payloadSize, 0);
        if (sent > 0) {
            VPN_SERVER_LOGI("âœ… [è½¬å‘-æ–°] æ•°æ®å·²å‘é€: %{public}zdå­—èŠ‚", sent);
            return existingConn.forwardSocket;
        } else {
            VPN_SERVER_LOGE("âŒ [è½¬å‘-æ–°] å‘é€å¤±è´¥ï¼Œç§»é™¤æ˜ å°„");
            NATTable::RemoveMapping(natKey);
            close(existingConn.forwardSocket);
        }
    }
    
    // 3. åˆ›å»ºæ–°è¿æ¥
    int addressFamily = (packetInfo.targetIP.find(':') != std::string::npos) ? AF_INET6 : AF_INET;
    int sockFd = CreateSocket(addressFamily, packetInfo.protocol);
    if (sockFd < 0) {
        VPN_SERVER_LOGE("âŒ [è½¬å‘-æ–°] åˆ›å»ºsocketå¤±è´¥");
        return -1;
    }
    
    // 4. å…ˆåˆ›å»ºNATæ˜ å°„ï¼ˆåœ¨å¯åŠ¨å“åº”çº¿ç¨‹ä¹‹å‰ï¼‰
    NATTable::CreateMapping(natKey, originalPeer, packetInfo, sockFd);
    
    // 5. æ ¹æ®åè®®è½¬å‘
    int result = -1;
    if (packetInfo.protocol == PROTOCOL_UDP) {
        result = HandleUDPForwarding(sockFd, payload, payloadSize, packetInfo, addressFamily, originalPeer);
    } else if (packetInfo.protocol == PROTOCOL_TCP) {
        result = HandleTCPForwarding(sockFd, payload, payloadSize, packetInfo, addressFamily, originalPeer);
    } else {
        VPN_SERVER_LOGE("âŒ [è½¬å‘-æ–°] ä¸æ”¯æŒçš„åè®®: %{public}d", packetInfo.protocol);
        NATTable::RemoveMapping(natKey);
        close(sockFd);
        return -1;
    }
    
    if (result < 0) {
        VPN_SERVER_LOGE("âŒ [è½¬å‘-æ–°] è½¬å‘å¤±è´¥");
        NATTable::RemoveMapping(natKey);
        close(sockFd);
        return -1;
    }
    
    VPN_SERVER_LOGI("âœ… [è½¬å‘-æ–°] è½¬å‘æˆåŠŸ, socket=%{public}d", result);
    return result;
}

// åˆ›å»ºsocket
int PacketForwarder::CreateSocket(int addressFamily, uint8_t protocol) {
    int sockType = (protocol == PROTOCOL_UDP) ? SOCK_DGRAM : SOCK_STREAM;
    int sockFd = socket(addressFamily, sockType, 0);
    
    if (sockFd < 0) {
        VPN_SERVER_LOGE("âŒ [åˆ›å»ºSocket] å¤±è´¥: %{public}s", strerror(errno));
        return -1;
    }
    
    // è®¾ç½®socketé€‰é¡¹
    int optval = 1;
    setsockopt(sockFd, SOL_SOCKET, SO_REUSEADDR, &optval, sizeof(optval));
    
    // è®¾ç½®éé˜»å¡æ¨¡å¼
    int flags = fcntl(sockFd, F_GETFL, 0);
    if (flags >= 0) {
        fcntl(sockFd, F_SETFL, flags | O_NONBLOCK);
    }
    
    VPN_SERVER_LOGI("âœ… [åˆ›å»ºSocket] æˆåŠŸ, fd=%{public}d, åœ°å€æ—=%{public}d, ç±»å‹=%{public}d", 
                    sockFd, addressFamily, sockType);
    return sockFd;
}

// å¤„ç†UDPè½¬å‘ - é‡æ„ç‰ˆï¼ˆåªè½¬å‘payloadï¼‰
int PacketForwarder::HandleUDPForwarding(int sockFd, const uint8_t* payload, int payloadSize,
                                        const PacketInfo& packetInfo,
                                        int addressFamily, const sockaddr_in& originalPeer) {
    VPN_SERVER_LOGI("ğŸ“® [UDP-æ–°] å¼€å§‹: ç›®æ ‡=%{public}s:%{public}d, payload=%{public}då­—èŠ‚",
                    packetInfo.targetIP.c_str(), packetInfo.targetPort, payloadSize);
    
    // æ„å»ºç›®æ ‡åœ°å€
    struct sockaddr_in serverAddr{};
    serverAddr.sin_family = AF_INET;
    serverAddr.sin_port = htons(packetInfo.targetPort);
    
    if (inet_pton(AF_INET, packetInfo.targetIP.c_str(), &serverAddr.sin_addr) <= 0) {
        VPN_SERVER_LOGE("âŒ [UDP-æ–°] æ— æ•ˆçš„IPåœ°å€: %{public}s", packetInfo.targetIP.c_str());
        return -1;
    }
    
    // å‘é€payloadï¼ˆåº”ç”¨å±‚æ•°æ®ï¼‰ï¼Œæ“ä½œç³»ç»Ÿä¼šè‡ªåŠ¨æ·»åŠ UDPå’ŒIPå¤´
    ssize_t sent = sendto(sockFd, payload, payloadSize, 0, 
                          (struct sockaddr*)&serverAddr, sizeof(serverAddr));
    
    if (sent < 0) {
        VPN_SERVER_LOGE("âŒ [UDP-æ–°] å‘é€å¤±è´¥: %{public}s", strerror(errno));
        return -1;
    }
    
    VPN_SERVER_LOGI("âœ… [UDP-æ–°] payloadå·²å‘é€: %{public}zdå­—èŠ‚ (OSä¼šè‡ªåŠ¨æ·»åŠ UDP/IPå¤´)", sent);
    
    if (IsDNSQuery(packetInfo.targetIP, packetInfo.targetPort)) {
        VPN_SERVER_LOGI("ğŸ” [DNSæŸ¥è¯¢] æ£€æµ‹åˆ°DNSæŸ¥è¯¢");
    }
    
    // å¯åŠ¨UDPå“åº”å¤„ç†çº¿ç¨‹
    std::thread(&PacketForwarder::HandleUdpResponse, sockFd, originalPeer, packetInfo).detach();
    
    return sockFd;
}

// å¤„ç†TCPè½¬å‘ - é‡æ„ç‰ˆï¼ˆåªè½¬å‘payloadï¼‰
int PacketForwarder::HandleTCPForwarding(int sockFd, const uint8_t* payload, int payloadSize,
                                        const PacketInfo& packetInfo,
                                        int addressFamily, const sockaddr_in& originalPeer) {
    VPN_SERVER_LOGI("ğŸ”— [TCP-æ–°] å¼€å§‹: ç›®æ ‡=%{public}s:%{public}d, payload=%{public}då­—èŠ‚",
                    packetInfo.targetIP.c_str(), packetInfo.targetPort, payloadSize);
    
    // æ„å»ºç›®æ ‡åœ°å€
    struct sockaddr_in serverAddr{};
    serverAddr.sin_family = AF_INET;
    serverAddr.sin_port = htons(packetInfo.targetPort);
    
    if (inet_pton(AF_INET, packetInfo.targetIP.c_str(), &serverAddr.sin_addr) <= 0) {
        VPN_SERVER_LOGE("âŒ [TCP-æ–°] æ— æ•ˆçš„IPåœ°å€: %{public}s", packetInfo.targetIP.c_str());
        return -1;
    }
    
    // è®¾ç½®socketä¸ºé˜»å¡æ¨¡å¼ï¼ˆTCPè¿æ¥éœ€è¦é˜»å¡ï¼‰
    int flags = fcntl(sockFd, F_GETFL, 0);
    fcntl(sockFd, F_SETFL, flags & ~O_NONBLOCK);
    
    // è¿æ¥ç›®æ ‡æœåŠ¡å™¨
    VPN_SERVER_LOGI("ğŸ”Œ [TCP-æ–°] æ­£åœ¨è¿æ¥ %{public}s:%{public}d...", 
                    packetInfo.targetIP.c_str(), packetInfo.targetPort);
    
    int connectResult = connect(sockFd, (struct sockaddr*)&serverAddr, sizeof(serverAddr));
    
    if (connectResult < 0) {
        VPN_SERVER_LOGE("âŒ [TCP-æ–°] è¿æ¥å¤±è´¥: %{public}s", strerror(errno));
        return -1;
    }
    
    VPN_SERVER_LOGI("âœ… [TCP-æ–°] è¿æ¥æˆåŠŸ");
    
    // å‘é€payloadï¼ˆåº”ç”¨å±‚æ•°æ®ï¼‰ï¼Œæ“ä½œç³»ç»Ÿä¼šè‡ªåŠ¨æ·»åŠ TCPå’ŒIPå¤´
    if (payloadSize > 0) {
        ssize_t sent = send(sockFd, payload, payloadSize, 0);
        
        if (sent < 0) {
            VPN_SERVER_LOGE("âŒ [TCP-æ–°] å‘é€å¤±è´¥: %{public}s", strerror(errno));
            return -1;
        }
        
        VPN_SERVER_LOGI("âœ… [TCP-æ–°] payloadå·²å‘é€: %{public}zdå­—èŠ‚ (OSä¼šè‡ªåŠ¨æ·»åŠ TCP/IPå¤´)", sent);
    } else {
        VPN_SERVER_LOGI("â„¹ï¸ [TCP-æ–°] æ— payloadï¼ˆTCPæ¡æ‰‹åŒ…ï¼‰");
    }
    
    // å¯åŠ¨TCPå“åº”å¤„ç†çº¿ç¨‹
    std::thread(&PacketForwarder::HandleTcpResponse, sockFd, originalPeer, packetInfo).detach();
    
    return sockFd;
}

// å¤„ç†UDPå“åº” - é‡æ„ç‰ˆï¼ˆé‡æ–°å°è£…æˆIPåŒ…ï¼‰
void PacketForwarder::HandleUdpResponse(int sockFd, sockaddr_in originalPeer, const PacketInfo& packetInfo) {
    VPN_SERVER_LOGI("ğŸ“¥ [UDPå“åº”-æ–°] å¼€å§‹ç›‘å¬: socket=%{public}d", sockFd);
    
    // æŸ¥æ‰¾NATæ˜ å°„
    NATConnection conn;
    if (!NATTable::FindMappingBySocket(sockFd, conn)) {
        VPN_SERVER_LOGE("âŒ [UDPå“åº”-æ–°] æœªæ‰¾åˆ°NATæ˜ å°„");
        close(sockFd);
        return;
    }
    
    uint8_t responsePayload[65535];  // åº”ç”¨å±‚å“åº”æ•°æ®
    struct sockaddr_in responseAddr{};
    socklen_t addrLen = sizeof(responseAddr);
    
    // è®¾ç½®æ¥æ”¶è¶…æ—¶ï¼ˆ30ç§’ï¼‰
    struct timeval timeout;
    timeout.tv_sec = 30;
    timeout.tv_usec = 0;
    setsockopt(sockFd, SOL_SOCKET, SO_RCVTIMEO, &timeout, sizeof(timeout));
    
    while (true) {
        // æ¥æ”¶å“åº”ï¼ˆåº”ç”¨å±‚æ•°æ®ï¼Œä¸åŒ…å«IP/UDPå¤´ï¼‰
        ssize_t received = recvfrom(sockFd, responsePayload, sizeof(responsePayload), 0,
                                    (struct sockaddr*)&responseAddr, &addrLen);
        
        if (received <= 0) {
            if (errno == EAGAIN || errno == EWOULDBLOCK) {
                VPN_SERVER_LOGI("â±ï¸ [UDPå“åº”-æ–°] æ¥æ”¶è¶…æ—¶");
            } else {
                VPN_SERVER_LOGE("âŒ [UDPå“åº”-æ–°] æ¥æ”¶å¤±è´¥: %{public}s", strerror(errno));
            }
            break;
        }
        
        VPN_SERVER_LOGI("ğŸ“¬ [UDPå“åº”-æ–°] æ”¶åˆ°payload: %{public}zdå­—èŠ‚", received);
        
        if (IsDNSQuery(packetInfo.targetIP, packetInfo.targetPort)) {
            VPN_SERVER_LOGI("ğŸ” [DNSå“åº”-æ–°] æ”¶åˆ°DNSå“åº”");
        }
        
        // é‡æ–°å°è£…æˆå®Œæ•´çš„IPæ•°æ®åŒ…
        uint8_t ipPacket[65535];
        int packetLen = PacketBuilder::BuildResponsePacket(
            ipPacket, sizeof(ipPacket),
            responsePayload, received,
            conn.originalRequest
        );
        
        if (packetLen < 0) {
            VPN_SERVER_LOGE("âŒ [UDPå“åº”-æ–°] æ„å»ºå“åº”åŒ…å¤±è´¥");
            break;
        }
        
        VPN_SERVER_LOGI("ğŸ“¦ [UDPå“åº”-æ–°] å·²æ„å»ºå®Œæ•´IPåŒ…: %{public}då­—èŠ‚", packetLen);
        
        // å‘é€å®Œæ•´IPåŒ…ç»™å®¢æˆ·ç«¯
        ssize_t sent = sendto(g_sockFd, ipPacket, packetLen, 0,
                             (struct sockaddr*)&conn.clientPhysicalAddr, 
                             sizeof(conn.clientPhysicalAddr));
        
        if (sent > 0) {
            VPN_SERVER_LOGI("âœ… [UDPå“åº”-æ–°] å®Œæ•´IPåŒ…å·²å‘é€ç»™å®¢æˆ·ç«¯: %{public}zdå­—èŠ‚", sent);
        } else {
            VPN_SERVER_LOGE("âŒ [UDPå“åº”-æ–°] å‘é€å¤±è´¥: %{public}s", strerror(errno));
        }
        
        // UDPé€šå¸¸æ˜¯ä¸€æ¬¡æ€§è¯·æ±‚/å“åº”
        break;
    }
    
    // æ¸…ç†NATæ˜ å°„å’Œsocket
    std::string natKey = NATTable::GenerateKey(conn.originalRequest);
    NATTable::RemoveMapping(natKey);
    close(sockFd);
    VPN_SERVER_LOGI("ğŸ”’ [UDPå“åº”-æ–°] å…³é—­socketå¹¶ç§»é™¤æ˜ å°„: %{public}d", sockFd);
}

// å¤„ç†TCPå“åº” - é‡æ„ç‰ˆï¼ˆé‡æ–°å°è£…æˆIPåŒ…ï¼‰
void PacketForwarder::HandleTcpResponse(int sockFd, sockaddr_in originalPeer, const PacketInfo& packetInfo) {
    VPN_SERVER_LOGI("ğŸ“¥ [TCPå“åº”-æ–°] å¼€å§‹ç›‘å¬: socket=%{public}d", sockFd);
    
    // æŸ¥æ‰¾NATæ˜ å°„
    NATConnection conn;
    if (!NATTable::FindMappingBySocket(sockFd, conn)) {
        VPN_SERVER_LOGE("âŒ [TCPå“åº”-æ–°] æœªæ‰¾åˆ°NATæ˜ å°„");
        close(sockFd);
        return;
    }
    
    uint8_t responsePayload[8192];  // åº”ç”¨å±‚å“åº”æ•°æ®
    
    // è®¾ç½®æ¥æ”¶è¶…æ—¶ï¼ˆ60ç§’ï¼‰
    struct timeval timeout;
    timeout.tv_sec = 60;
    timeout.tv_usec = 0;
    setsockopt(sockFd, SOL_SOCKET, SO_RCVTIMEO, &timeout, sizeof(timeout));
    
    while (true) {
        // æ¥æ”¶å“åº”ï¼ˆåº”ç”¨å±‚æ•°æ®ï¼Œä¸åŒ…å«IP/TCPå¤´ï¼‰
        ssize_t received = recv(sockFd, responsePayload, sizeof(responsePayload), 0);
        
        if (received <= 0) {
            if (received == 0) {
                VPN_SERVER_LOGI("ğŸ”š [TCPå“åº”-æ–°] è¿æ¥å…³é—­");
            } else if (errno == EAGAIN || errno == EWOULDBLOCK) {
                VPN_SERVER_LOGI("â±ï¸ [TCPå“åº”-æ–°] æ¥æ”¶è¶…æ—¶");
            } else {
                VPN_SERVER_LOGE("âŒ [TCPå“åº”-æ–°] æ¥æ”¶å¤±è´¥: %{public}s", strerror(errno));
            }
            break;
        }
        
        VPN_SERVER_LOGI("ğŸ“¬ [TCPå“åº”-æ–°] æ”¶åˆ°payload: %{public}zdå­—èŠ‚", received);
        
        // æ›´æ–°æ´»åŠ¨æ—¶é—´
        std::string natKey = NATTable::GenerateKey(conn.originalRequest);
        NATTable::UpdateActivity(natKey);
        
        // é‡æ–°å°è£…æˆå®Œæ•´çš„IPæ•°æ®åŒ…
        uint8_t ipPacket[8192 + 60];  // payload + IPå¤´ + TCPå¤´
        int packetLen = PacketBuilder::BuildResponsePacket(
            ipPacket, sizeof(ipPacket),
            responsePayload, received,
            conn.originalRequest
        );
        
        if (packetLen < 0) {
            VPN_SERVER_LOGE("âŒ [TCPå“åº”-æ–°] æ„å»ºå“åº”åŒ…å¤±è´¥");
            break;
        }
        
        VPN_SERVER_LOGI("ğŸ“¦ [TCPå“åº”-æ–°] å·²æ„å»ºå®Œæ•´IPåŒ…: %{public}då­—èŠ‚", packetLen);
        
        // å‘é€å®Œæ•´IPåŒ…ç»™å®¢æˆ·ç«¯
        ssize_t sent = sendto(g_sockFd, ipPacket, packetLen, 0,
                             (struct sockaddr*)&conn.clientPhysicalAddr,
                             sizeof(conn.clientPhysicalAddr));
        
        if (sent > 0) {
            VPN_SERVER_LOGI("âœ… [TCPå“åº”-æ–°] å®Œæ•´IPåŒ…å·²å‘é€ç»™å®¢æˆ·ç«¯: %{public}zdå­—èŠ‚", sent);
        } else {
            VPN_SERVER_LOGE("âŒ [TCPå“åº”-æ–°] å‘é€å¤±è´¥: %{public}s", strerror(errno));
            break;
        }
    }
    
    // æ¸…ç†NATæ˜ å°„å’Œsocket
    std::string natKey = NATTable::GenerateKey(conn.originalRequest);
    NATTable::RemoveMapping(natKey);
    close(sockFd);
    VPN_SERVER_LOGI("ğŸ”’ [TCPå“åº”-æ–°] å…³é—­socketå¹¶ç§»é™¤æ˜ å°„: %{public}d", sockFd);
}

// æ£€æŸ¥æ˜¯å¦ä¸ºDNSæŸ¥è¯¢
bool PacketForwarder::IsDNSQuery(const std::string& targetIP, int targetPort) {
    // DNSé€šå¸¸ä½¿ç”¨ç«¯å£53
    if (targetPort != 53) {
        return false;
    }
    
    // å¸¸è§çš„DNSæœåŠ¡å™¨IP
    return (targetIP == "8.8.8.8" || 
            targetIP == "8.8.4.4" || 
            targetIP == "1.1.1.1" ||
            targetIP == "114.114.114.114" ||
            targetIP == "223.5.5.5" ||
            targetIP == "223.6.6.6");
}

// æµ‹è¯•ç½‘ç»œè¿æ¥ - ç®€åŒ–ç‰ˆæœ¬
bool PacketForwarder::TestNetworkConnectivity() {
    VPN_SERVER_LOGI("ğŸ” [ç½‘ç»œæµ‹è¯•] å¼€å§‹ç®€å•çš„ç½‘ç»œæµ‹è¯•...");
    
    // å¼‚æ­¥æ‰§è¡Œï¼Œé¿å…é˜»å¡ä¸»çº¿ç¨‹
    std::thread([]() {
        int sock = socket(AF_INET, SOCK_STREAM, 0);
        if (sock < 0) {
            VPN_SERVER_LOGE("âŒ [ç½‘ç»œæµ‹è¯•] socketåˆ›å»ºå¤±è´¥");
            return;
        }
        
        // æµ‹è¯•è¿æ¥ç™¾åº¦ 110.242.68.66:80
        struct sockaddr_in addr{};
        addr.sin_family = AF_INET;
        addr.sin_port = htons(80);
        inet_pton(AF_INET, "110.242.68.66", &addr.sin_addr);
        
        // ç®€å•çš„é˜»å¡å¼è¿æ¥æµ‹è¯•ï¼ˆåœ¨åå°çº¿ç¨‹ï¼Œä¸å½±å“ä¸»çº¿ç¨‹ï¼‰
        int result = connect(sock, (struct sockaddr*)&addr, sizeof(addr));
        
        if (result == 0) {
            VPN_SERVER_LOGI("âœ… [ç½‘ç»œæµ‹è¯•] ç½‘ç»œè¿æ¥æ­£å¸¸");
        } else {
            VPN_SERVER_LOGE("âŒ [ç½‘ç»œæµ‹è¯•] ç½‘ç»œè¿æ¥å¤±è´¥");
        }
        
        close(sock);
    }).detach();
    
    return true;
}
